type Query {
  themeCount: Int @cypher(statement: "MATCH (t:Theme) RETURN COUNT(t)")
  setCount: Int
    @cypher(statement: "MATCH (n:Set) RETURN COUNT(DISTINCT(n.set_num))")
  themePrices: [ThemePrice]
    @cypher(
      statement: """
      MATCH (n:Set)
      WHERE EXISTS(n.derived_theme) AND EXISTS(n.USD_MSRP)
      WITH n.derived_theme AS theme, AVG(n.USD_MSRP) AS average
      RETURN {theme: theme, USD_average: average} as Obj
      ORDER BY average DESC
      """
    )
  subthemePrices: [ThemePrice]
    @cypher(
      statement: """
      MATCH (n:Set)
      WHERE EXISTS(n.derived_subtheme) AND EXISTS(n.USD_MSRP)
      WITH n.derived_subtheme AS theme, AVG(n.USD_MSRP) AS average
      RETURN {theme: theme, USD_average: average} as Obj
      ORDER BY average DESC
      """
    )
  averagePartsPerYear: [YearWisePartsAverage]
    @cypher(
      statement: """
      MATCH (n:Set)
      WHERE EXISTS(n.num_parts)
      WITH n.year AS year, AVG(n.num_parts) AS average
      RETURN {year: year, average: average} as Obj
      ORDER BY year DESC
      """
    )
  themesReleasedPerYear: [YearwiseThemeCount]
    @cypher(
      statement: """
      MATCH (n:Set)-[:HAS_THEME]->(t:Theme)
      WHERE EXISTS (n.year)
      WITH n.year AS year, COUNT(DISTINCT(t.id)) AS themeCount
      RETURN {year: year, themeCount: themeCount} as Obj
      ORDER BY year DESC
      """
    )
  uniquePartsPerColor: [PartsPerColor]
    @cypher(
      statement: """
      MATCH (i:InventoryPart)-[:FOR_PART]->(p:Part)
      MATCH (i:InventoryPart)-[:HAS_COLOR]->(c:Color)
      WHERE EXISTS (p.part_num) AND c.name <> '[No Color]' AND c.name <> 'Unknown'
      WITH c.name AS color, COUNT(DISTINCT(p.part_num)) AS num_parts
      RETURN {color: color, num_parts: num_parts} as Obj
      ORDER BY num_parts DESC
      """
    )
  #   uniqueSetsPerColorPerYear: [SetsPerColorPerYear]
  #     @cypher(
  #       statement: """
  #       MATCH (ip:InventoryPart)-[:ASSOCIATED_INVENTORY]->(i:Inventory)
  #       MATCH (ip:InventoryPart)-[:HAS_COLOR]->(c:Color)
  #       MATCH (i:Inventory)-[:INVENTORY_FOR]->(s:Set)
  #       WHERE EXISTS (ip.inventory_id) AND  c.name IN ['Black', 'White', 'Yellow', 'Red']
  #       WITH DISTINCT(s.year) AS year, c.name as color, COUNT(DISTINCT(s.name)) AS num_sets
  #       RETURN {year:year, color:color, count:num_sets} as Obj
  #       ORDER BY Obj.year DESC
  #       """
  #     )
  setsWithMaxColorPerYear: [maxColorSetsPerYear]
    @cypher(
      statement: """
      MATCH (ip:InventoryPart)-[:ASSOCIATED_INVENTORY]->(i:Inventory)
      MATCH (ip:InventoryPart)-[:HAS_COLOR]->(c:Color)
      MATCH (i:Inventory)-[:INVENTORY_FOR]->(s:Set)
      WHERE EXISTS (ip.inventory_id) AND c.name <> '[No Color]' AND c.name <> 'Unknown'
      WITH s.year AS year, s.name as set_name, COUNT(DISTINCT(c.name)) AS num_colors
      RETURN {year:year, set_name: set_name, num_colors: num_colors} as Obj
      ORDER BY num_colors DESC
      LIMIT 15
      """
    )
  topThemesBasedOnSetCount: [topThemes]
    @cypher(
      statement: """
      MATCH (s:Set)-[:HAS_THEME]->(t:Theme)
      WITH DISTINCT(t.name) as name, COUNT(s.set_num) as count
      RETURN {name: name, count: count} AS Obj
      ORDER BY count DESC
      LIMIT 15
      """
    )

  legosetPriceTrend: [setPriceTrend]
    @cypher(
      statement: """
      MATCH (n:Set)
      WHERE EXISTS(n.year) and EXISTS(n.USD_MSRP)
      WITH n.year AS year, AVG(n.USD_MSRP) AS average
      RETURN {year: year, USD_average: average} as Obj
      ORDER BY year DESC
      """
    )

  #  Redundant Open
  blackColorSetsTrend: [colorSetsTrend]
    @cypher(
      statement: """
      MATCH (ip:InventoryPart)-[:ASSOCIATED_INVENTORY]->(i:Inventory)
      MATCH (ip:InventoryPart)-[:HAS_COLOR]->(c:Color)
      MATCH (i:Inventory)-[:INVENTORY_FOR]->(s:Set)
      WHERE EXISTS (ip.inventory_id) AND c.name = 'Black'
      WITH DISTINCT(s.year) AS year, COUNT(DISTINCT(s.name)) AS num_sets
      RETURN {year:year, num_sets:num_sets} as Obj
      ORDER BY year DESC
      """
    )
  whiteColorSetsTrend: [colorSetsTrend]
    @cypher(
      statement: """
      MATCH (ip:InventoryPart)-[:ASSOCIATED_INVENTORY]->(i:Inventory)
      MATCH (ip:InventoryPart)-[:HAS_COLOR]->(c:Color)
      MATCH (i:Inventory)-[:INVENTORY_FOR]->(s:Set)
      WHERE EXISTS (ip.inventory_id) AND c.name = 'White'
      WITH DISTINCT(s.year) AS year, COUNT(DISTINCT(s.name)) AS num_sets
      RETURN {year:year, num_sets:num_sets} as Obj
      ORDER BY year DESC
      """
    )
  redColorSetsTrend: [colorSetsTrend]
    @cypher(
      statement: """
      MATCH (ip:InventoryPart)-[:ASSOCIATED_INVENTORY]->(i:Inventory)
      MATCH (ip:InventoryPart)-[:HAS_COLOR]->(c:Color)
      MATCH (i:Inventory)-[:INVENTORY_FOR]->(s:Set)
      WHERE EXISTS (ip.inventory_id) AND c.name = 'Red'
      WITH DISTINCT(s.year) AS year, COUNT(DISTINCT(s.name)) AS num_sets
      RETURN {year:year, num_sets:num_sets} as Obj
      ORDER BY year DESC
      """
    )
  # Redundant Close
  legosetsPartsPerTheme: [setPartsPerTheme]
    @cypher(
      statement: """
      MATCH (s:Set)-[:HAS_THEME]->(t:Theme)
      WHERE EXISTS(s.name)
      WITH s.name as setname, t.name as theme, SUM(s.num_parts) as num_parts
      RETURN {setname: setname, theme: theme, num_parts: num_parts} AS Obj
      ORDER BY num_parts DESC
      """
    )
}

type setPartsPerTheme {
  setname: String
  theme: String
  num_parts: Int
}

type colorSetsTrend {
  year: Int
  num_sets: Int
}

type topThemes {
  name: String
  count: Int
}

type setPriceTrend {
  year: String
  USD_average: Float
}

type maxColorSetsPerYear {
  year: Int
  set_name: String
  num_colors: Int
}

# type SetsPerColorPerYear {
#   year: Int
#   color: String
#   count: Int
# }

type ThemePrice {
  theme: String
  USD_average: Float
}

type YearWisePartsAverage {
  year: Int
  average: Float
}

type YearwiseThemeCount {
  year: Int
  themeCount: Int
}

type PartsPerColor {
  color: String
  num_parts: Int
}

type Theme {
  _id: Long!
  id: String!
  name: String!
  has_parent_theme: [Theme]
    @relation(name: "HAS_PARENT_THEME", direction: "OUT")
  sets: [Set] @relation(name: "HAS_THEME", direction: "IN")
}

type Set {
  _id: Long!
  CAD_MSRP: Float
  EUR_MSRP: Float
  GBP_MSRP: Float
  USD_MSRP: Float
  derived_subtheme: String
  derived_theme: String
  name: String
  num_parts: Int
  set_num: String
  year: Int
  has_theme: [Theme] @relation(name: "HAS_THEME", direction: "OUT")
  inventorys: [Inventory] @relation(name: "INVENTORY_FOR", direction: "IN")
}

type PartCategory {
  _id: Long!
  id: String!
  name: String!
  parts: [Part] @relation(name: "HAS_PART_CATEGORY", direction: "IN")
}

type Part {
  _id: Long!
  name: String!
  part_num: String!
  has_part_category: [PartCategory]
    @relation(name: "HAS_PART_CATEGORY", direction: "OUT")
  inventoryparts: [InventoryPart] @relation(name: "FOR_PART", direction: "IN")
}

type Color {
  _id: Long!
  id: String!
  is_trans: String!
  name: String!
  rgb: String!
  inventoryparts: [InventoryPart] @relation(name: "HAS_COLOR", direction: "IN")
}

type Inventory {
  _id: Long!
  id: String!
  version: String!
  inventory_for: [Set] @relation(name: "INVENTORY_FOR", direction: "OUT")
  INVENTORY_FOR_rel: [INVENTORY_FOR]
  inventoryparts: [InventoryPart]
    @relation(name: "ASSOCIATED_INVENTORY", direction: "IN")
}

type InventoryPart {
  _id: Long!
  color_id: String!
  inventory_id: String!
  is_spare: String!
  part_num: String!
  quantity: String!
  has_color: [Color] @relation(name: "HAS_COLOR", direction: "OUT")
  for_part: [Part] @relation(name: "FOR_PART", direction: "OUT")
  associated_inventory: [Inventory]
    @relation(name: "ASSOCIATED_INVENTORY", direction: "OUT")
}

type Master {
  _id: Long!
  cad_price: Float
  colors: [String]!
  distinct_parts: Int!
  eur_price: Float
  gbp_price: Float
  inventoryId: String!
  num_parts: Int!
  parentTheme: String!
  part_categories: [String]!
  setname: String!
  theme: String!
  usd_price: Float!
  year: Int!
}

type INVENTORY_FOR @relation(name: "INVENTORY_FOR") {
  from: Inventory!
  to: Set!
  setQuantity: String
}
